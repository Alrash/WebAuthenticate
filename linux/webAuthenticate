#!/usr/bin/env python
# coding=utf-8

# Author: alrash
# email: kasukuikawai@gmail.com
# version: Beta version

import json
import urllib
import urllib.request
import base64                       #认证密码使用
import sys
import errno                        #(#1)没发现文件，解决方法google python3 filenotfounderror
import re
import socket
import os
import time
from subprocess import check_output, CalledProcessError
import signal

try:
    import argparse
except ImportError:
    sys.stderr.write("The required Argparse modules could not be loaded.\n")
    sys.exit(1)

#check python version
if sys.version_info.major == 2:
    sys.stderr.write("Please run this script above the Python 2 executable.\n ")
    sys.exit(1)

#Handle command-line arguments with Argparse module
parse = argparse.ArgumentParser(description = '命令行控制认证网络')
parse.add_argument('-I', '--login', action = 'store_true', dest = 'login', help='接入Internet')
parse.add_argument('-s', '--section', action = 'store', dest = 'section', help='设置使用组组名')
parse.add_argument('-t', '--time', action = 'store', dest = 'time', type = int, help='设置倒计时时间，单位s')
parse.add_argument('-S', '--status', action = 'store_true', dest = 'status', help='显示当前信息')
parse.add_argument('-O', '--logout', action = 'store_true', dest = 'logout', help='断开Internet')
parse.add_argument('-v', '--version', action = 'version', version='%(prog)s 1.0')

#解析参数
args = parse.parse_args()

path = '/etc/webAuthenticate'
jsonFile =  path + '/webAuthenticate.json'
serviceProvider = ['CMCC', 'ChinaNet', 'Unicom']
scriptName = os.path.basename(__file__)

url = 'http://a.nuist.edu.cn/index.php'
urlInit = url + '/index/init'
urlLogin = url + '/index/login'
urlLogout = url + '/index/logout'

username = ''
password = ''
provider = ''
enablemacauth = 0                   #没发现有什么用，但是要传-_-|||
wifi = False

#读取配置文件，若含有alias别名的组，则返回该组内容，否则则为None
def get_json_info(filename, alias):
    try:
        with open(filename, 'r') as f:
            data = json.load(f)
    except OSError as e:            #1
        if e.errno == errno.ENOENT:
            sys.stderr.write('cannot find the file {0}.\n'.format(jsonFile));
            sys.exit(-1)
        else:
            sys.stderr.write('permission denied {0}.\n'.format(jsonFile));
            sys.exit(-1)

    for item in data:
        if item['alias'] == alias:
            return item

    return None

#认证页使用base64对密码进行编码，然后传送
def encode_password(password, encrypt = False):
    return password if encrypt == True else base64.b64encode(password.encode(encoding = 'utf-8')).decode()

#返回00:00:00形式的时间格式
def time_format(seconds):
    seconds = seconds if seconds > 0 else 0
    return '{:02d}'.format(seconds // 3600) + ":" + '{:02d}'.format(seconds // 60 % 60) + ":" + '{:02d}'.format(seconds % 60)

#通用的发送数据的方法
#web认证页面没有跟踪cookie，这里简化处理（很容易爆）
#返回json格式的数据
def get_status_with_json(url, data = None):
    request = urllib.request.Request(url)
    try:
        response = urllib.request.urlopen(request, data if data is None else data.encode(encoding = 'utf-8'), timeout = 2)
    except urllib.error.URLError:
        sys.stderr.write('maybe, your connected wifi is not i-NUIST\n')
        sys.exit(-1)
    except socket.timeout:
        sys.stderr.write('response time out\n')
        sys.exit(-1)
    return json.loads(response.read().decode())

#额。。偷懒使用windows下的部分方法，于是有了这个
#为username之类的全局变量赋值
def get_ini(alias):
    data = get_json_info(jsonFile, alias)
    if data == None:
        sys.stderr.write('cannot find alias {0} in {1}'.format(alias, jsonFile))
        sys.exit(1)

    global password, username, provider
    username = data['username']
    provider = data['provider']
    password = encode_password(data['password'], data['encrypt'])

def show_status_info(status):
    print("*****************************************************")
    for key in sorted(status.keys()):
        if key != 'status' and key != 'data':
            print('%-16s| %s'%(key, time_format(status[key]) if re.compile(r'.*timer').match(key) else status[key]))
    print("*****************************************************")

#连接/登录
def login(alias):
    #获取当前状态，若已登录，显示状态后退出
    status = get_status_with_json(urlInit)
    if status['status'] != 0:
        show_status_info(status)
        return

    #获取配置信息
    get_ini('alrash')

    #发送登录信息
    data = {'username': username, 'domain': provider, 'password' : password, 'enablemacauth': enablemacauth}
    status = get_status_with_json(urlLogin, urllib.parse.urlencode(data))
    if status['status'] != 0:
        print('login success')
    else:
        print("*****************************************************")
        print("login fail, please check your username, password and service provider")
        print("\tNote that uppercase and lowercase letters")
        print("\tanother case: web page change its api")
        print("username: " + username)
        print("password: " + base64.b64decode(password).decode())
        print("provider: " + provider)
        print("*****************************************************")

    return

#显示当前状态
def show_info():
    status = get_status_with_json(urlInit)
    show_status_info(status)
    return

#登出/取消连接
def logout():
    status = get_status_with_json(urlInit)
    if status['status'] != 0:
        status = get_status_with_json(urlLogout)

        if status['status'] != 0:
            print('logout success')
        else:
            print('unknown error, perhaps this script becomes useless!')
    else:
        print('not connected i-NUIST wifi or have logouted')
    return

#伪守护进程
#(#2)守护进程，参照https://gist.github.com/jamiesun/3097215
def fake_daemon(countDown):
    #杀死原本的进程
    try:
        pid_map = list(map(int, check_output('ps aux | grep -E "python .*%s" | grep -v "grep" | awk \'{printf("%%d ", $2);}\''%(os.path.basename(__file__)), shell=True).decode().split()))
        for item in pid_map:
            if item != os.getpid() and item != 0:
                os.kill(item, signal.SIGKILL)
    except CalledProcessError:
        pass

    #stdin = '/dev/full'
    #stdout = '/dev/tty'
    #stderr = '/dev/ty'
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        sys.stderr.write("fork #1 failed: %d (%s).\n"%(e.errno, e.strerror))
        sys.exit(-1)

    #貌似可以不用了
    os.chdir('/')
    os.setsid()
    os.umask(0)

    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError as e:
        sys.stderr.write("fork #2 failed: %d (%s).\n"%(e.errno, e.strerror))
        sys.exit(-1)

    #sys.stdout.flush()
    #sys.stderr.flush()

    #退出登录
    time.sleep(countDown)
    logout()

#强制连接i-NUIST wifi
#由于是自己用的，这里需要networkmanage的nmcli模块
#连接设备是wlp3s0
if check_output('nmcli dev | grep wlp3s0 | awk \'{print $4}\' | tr -d "\n"', shell = True).decode() == 'i-NUIST':
    wifi = True

#正式函数功能
if args.status:
    if wifi:
        show_info()
        sys.exit(0)
    else:
        print("not connected wifi i-NUIST")
        sys.exit(0)

if args.login:
    if not wifi:
        print('be ready to connect i-NUIST wifi')
        os.system("nmcli dev wifi connect i-NUIST")

    if args.section:
        login(args.section)
    else:
        sys.stderr.write("没有使用-s参数设置组名.\n")
        sys.exit(-1)

    if args.time and args.time != 0:
        fake_daemon(args.time)
    sys.exit(0)

if args.logout:
    if wifi:
        logout()
        sys.exit(0)
    else:
        print("not connected wifi i-NUIST")
        sys.exit(0)
